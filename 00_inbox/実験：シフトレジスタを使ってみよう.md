
実験日：2025/12/25

[[74HC595]]についてまずは調べてみる。

## 用意するもの
- [[Arduino]] UNO
- [[74HC595]] (DIP 16ピン)
- 共通カソードの7セグ
- 抵抗 x 7

## 配線
### Arduino → 74HC595

| **Arduino** | **74HC595** | **役割** |
| ----------- | ----------- | ------ |
| 5V          | 16 (VCC)    | 電源     |
| GND         | 8 (GND)     | グランド   |
| D11         | 14 (DS)     | データ    |
| D12         | 11 (SH_CP)  | クロック   |
| D8          | 12 (ST_CP)  | ラッチ    |

### 固定するピン

| **74HC595** | **どこへ** |
| ----------- | ------- |
| 13 (OE)     | GND     |
| 10 (MR)     | 5V      |

### 74HC595 → 7セグ

|**74HC595**|**7セグ**|
|---|---|
|15 (Q0)|a|
|1 (Q1)|b|
|2 (Q2)|c|
|3 (Q3)|d|
|4 (Q4)|e|
|5 (Q5)|f|
|6 (Q6)|g|

### 配線した

![[2025-12-25_シフトレジスタと7セグ.jpeg|400]]

## コード

とりあえず動作確認用のコードを書く。

```cpp
const int DATA  = 11;
const int CLOCK = 12;
const int LATCH = 8;

void setup() {
  pinMode(DATA, OUTPUT);
  pinMode(CLOCK, OUTPUT);
  pinMode(LATCH, OUTPUT);
}

void loop() {
  digitalWrite(LATCH, LOW);
  shiftOut(DATA, CLOCK, MSBFIRST, B01111111); // 8
  digitalWrite(LATCH, HIGH);
}
```

上記のコードをアップロードして、8が表示された。
とりあえずOK

### カウントアップさせる

```cpp
const int DATA  = 11;
const int CLOCK = 12;
const int LATCH = 8;

const byte digitBits[10] = {
  B00111111, // 0
  B00000110, // 1
  B01011011, // 2
  B01001111, // 3
  B01100110, // 4
  B01101101, // 5
  B01111101, // 6
  B00000111, // 7
  B01111111, // 8
  B01101111  // 9
};

void sendByte(byte bits) {
  digitalWrite(LATCH, LOW);
  shiftOut(DATA, CLOCK, MSBFIRST, bits);
  digitalWrite(LATCH, HIGH);
}

void setup() {
  pinMode(DATA, OUTPUT);
  pinMode(CLOCK, OUTPUT);
  pinMode(LATCH, OUTPUT);
}

void loop() {
  for (int n = 0; n <= 9; n++) {
    sendByte(digitBits[n]);
    delay(500);
  }
}
```

OK、問題なし。

### ボタンでカウントアップ

大部分は[[実験：delayを使わずにチャタリング対策|以前の実験]]からコードを流用する。
ボタンの配線も以前と同様、以下の通り。
```
D9 → ボタン → GND
```

```cpp
const int DATA  = 11;
const int CLOCK = 12;
const int LATCH = 8;

const int buttonPin = 9;

const byte digitBits[10] = {
  B00111111, B00000110, B01011011, B01001111, B01100110,
  B01101101, B01111101, B00000111, B01111111, B01101111
};

int count = 0;

// debounce
int stableState = HIGH;
int lastReading = HIGH;
unsigned long lastChangeTime = 0;
const unsigned long debounceMs = 30;

void sendByte(byte bits) {
  digitalWrite(LATCH, LOW);
  shiftOut(DATA, CLOCK, MSBFIRST, bits);
  digitalWrite(LATCH, HIGH);
}

void setup() {
  pinMode(DATA, OUTPUT);
  pinMode(CLOCK, OUTPUT);
  pinMode(LATCH, OUTPUT);

  pinMode(buttonPin, INPUT_PULLUP);

  sendByte(digitBits[count]);
}

void loop() {
  int reading = digitalRead(buttonPin);

  if (reading != lastReading) {
    lastChangeTime = millis();
  }

  if ((millis() - lastChangeTime) > debounceMs) {
    if (reading != stableState) {
      stableState = reading;

      if (stableState == LOW) {
        count = (count + 1) % 10;
      }
    }
  }

  lastReading = reading;

  // 表示は常に現在のcount
  sendByte(digitBits[count]);
}
```

無事、ボタンでカウントアップ出来た。

## 実験は成功だ！

シフトレジスタを使って7セグの表示に成功した。

...でも、なんでシフトレジスタを使うのだ？
Arduino直結のときと比べて、パーツが増えているだけな気がする。

## なぜシフトレジスタが良いの？

「制御」と「表現」を分離するため

### Arduino 直結だった世界線

Arduinoのピン = 表現そのもの

- aセグ = D2
- bセグ = D3
- ...

配線 = 意味

ピン番号が増えるほど、頭が配線に引きずられる。

### シフトレジスタを使った世界線

Arduino → データ → 表現

- Arduinoは「01101111」を送るだけ
- 74HC595がそれを形にする

Arduinoは意味だけを見る。
配線は74HC595の仕事である。

コードのこの部分、
```cpp
sendByte(digitBits[count]);
```

これが最重要。
直結していたときは、
「8を表示するから、こことこことここを光らせて...」
とやっていたが、今回は、
「8を表示する」
だけにとどまっており、Arduinoが7セグで8を表示させるための方法を考えなくて済むようになっている。

### 例えるなら

舞台演出の証明。

シフトレジスタ無し：「このシーンでは、左のライトと右のライトを点灯させて...」

シフトレジスタ有り：「証明パターン3番！」

### Arduinoを司令塔にしてくれるパーツ

それが74HC595である。